# 定时器

## 定时器
Timer定时器源码实现，和自定义一个线程方式一样，都是继承Thread类，重写了run()方法，只是实现的功能是延时执行一个函数或方法。

#### （1）线程定时器(Timer)解释：
Timer类是Thread的子类，只加入了时间延迟功能。
Thread和Timer对象都用start()方法启动。
启动Timer后，等于单独启动一个线程，为非阻塞的。

#### （2）Timer 的两种用法：
正常用法：启动后，延时执行函数或方法。
特殊用法：每隔n秒，执行一次函数或方法，就是不断地启动定时器。

## 2.队列

* queue.Queue( )：先入先出。
* queue.LifoQueue( )：后入先出。
* queue.PriorityQueue() ：可设置优先级。
* Queue.put()：往队列放数据。
* Qveue .get()：从队列取数据。
* Quewe.task.done()：配合get使用，告诉队列本次完成。
* Queue.qsize()：获取数据的数量。
* Queue.full()/empty()：判满/空。
* Queue.join()：等待线程完成。

## 3.线程池：

线程池在系统启动时即创建大量空闲的线程，程序只要将一个函数提交给线程池，线程池就会启动一个空闲的线程来执行它。当该函数执行结束后，该线程并不会死亡，而是再次返回到线程池中变成空闲状态，等待执行下一个函数。

使用线程池可以有效地控制系统中并发线程的数量。当系统中包含有大量的并发线程时，会导致系统性能急剧下降，甚至导致Python解释器崩溃，而线程池的最大线程数参数可以控制系统中并发线程的数量不超过此数，从而节省线程创建和销毁的开销，能带来更好的性能和系统稳定性。



![](../images/timer-1.png)

4.案例
使用定时器实现当前时间每秒循环输出一次。

##### Timer：
```
import threading
import time

# run函数
def run():
print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))  # 输出当地时间
timer = threading.Timer(1, run)  # 设置一个定时器，循环输出时间
timer.start()  # 启动线程

run()
```
运行结果：

```
2022-01-22 20:22:15
2022-01-22 20:22:16
2022-01-22 20:22:17
2022-01-22 20:22:18
2022-01-22 20:22:19
2022-01-22 20:22:20
2022-01-22 20:22:21
2022-01-22 20:22:22
2022-01-22 20:22:23
2022-01-22 20:22:24
2022-01-22 20:22:25
```